Alright, let's break down the logic for non-custom rules within the `dq_engine` function. This will help you understand how non-custom rules are processed and checked:

---

**Executing Non-Custom Rules**:

1. **Data Retrieval**:
   - Use the `get_rule_query_response_data` method to fetch the data based on the rule's query. The fetched data will be stored in `rule_query_response_df`.

2. **Data Verification**:
   - Check if the returned data (`rule_query_response_df`) is a DataFrame. 
   
3. **Handle No Data or Unexpected Response**:
   - If the response indicates that no data exists or the DataFrame is empty, log a message that no data was found for the rule's query and continue to the next rule.
   
4. **Attribute Formatting**:
   - Verify if the key attribute name (`OBJ_UNQ_ATTR_NM`) from the rule matches a column in the fetched data.
   - If not, update the key attribute name in the rule details and in the database.

5. **Data Preparation**:
   - Update the DataFrame with a composite key derived from the key attribute name.
   - Determine the total size of the unique data based on the key attribute.

6. **Data Filtering**:
   - Check for any missing filter or non-included filter attributes in the DataFrame. If there's an issue, log the error message and skip further processing of this rule.

7. **Attribute Verification**:
   - If the rule is designed to check attributes not present in the source data (`DIR_BRKS_FM_SRC_IN` is 'N'), verify the attribute to be checked (`CHK_ATTR_NM`). If it doesn't match with the DataFrame's columns, update the attribute name in the rule details and the database.

8. **Conformity Check**:
   - Extract the conformity values associated with the rule.
   - Check the data against these conformity values to identify any exceptions. This results in the `rule_exceptions_df`, a DataFrame containing records that don't conform to the rule.

9. **Exception Handling**:
   - If the `rule_exceptions_df` contains exceptions:
     - Compute the number of unique exceptions based on the key attribute.
     - Store these exceptions in the database.
     - Log the status of the rule execution with the number of exceptions found.
     - Optionally, trigger any post-rule execution jobs.
   - If there are no exceptions:
     - Log the successful execution of the rule, indicating no exceptions were found.

10. **Handling Other Response Scenarios**:
   - If the data retrieval response is other than a DataFrame (e.g., an HTTP response indicating an error), log the unexpected response.
   - If no data is returned at all, log a message indicating a `NoneType` response was received.

11. **Error Handling for Each Rule**:
   - If any errors or exceptions occur during the processing of a specific rule, these are caught, logged, and the process continues with the next rule.

---

This detailed flow provides an understanding of how non-custom rules are processed within the `dq_engine` function. It should help you create a comprehensive segment of the flowchart specifically for non-custom rule processing.
